import { existsSync, mkdirSync, writeFileSync } from 'node:fs';
import { join, resolve } from 'node:path';
import type { NextConfig } from 'next';
import type { AgentSeoOptions } from '@agent-seo/core';

export interface WithAgentSeoOptions extends AgentSeoOptions {
  /**
   * Absolute path to the Next.js `app/` directory.
   * If omitted, auto-detected by checking `./app` and `./src/app` from cwd.
   */
  appDir?: string;
  /**
   * Sitemap URL for the `robots.txt` Sitemap directive.
   * - `true`: uses `{baseUrl}/sitemap.xml`
   * - `string`: uses the provided URL
   * - `undefined`/`false`: no Sitemap directive
   */
  sitemap?: boolean | string;
}

/**
 * Next.js config plugin that:
 * 1. Auto-generates `app/llms.txt/route.ts` (zero-config `/llms.txt` endpoint)
 * 2. Injects `Vary: Accept, User-Agent` headers on all pages
 *
 * @example
 * ```ts
 * // next.config.ts
 * import { withAgentSeo } from '@agent-seo/next';
 *
 * export default withAgentSeo({
 *   siteName: 'My App',
 *   siteDescription: 'A brief description for LLMs.',
 *   baseUrl: 'https://myapp.com',
 * })({});
 * ```
 */
export function withAgentSeo(agentSeoOptions: WithAgentSeoOptions) {
  const appDir = agentSeoOptions.appDir || detectAppDir();

  // Auto-generate route handlers at config-evaluation time
  if (appDir) {
    generateLlmsTxtRoute(appDir, agentSeoOptions);
    generateTransformRoute(appDir, agentSeoOptions);
    generateRobotsTxt(appDir, agentSeoOptions);
  }

  return (nextConfig: NextConfig = {}): NextConfig => {
    return {
      ...nextConfig,

      async headers() {
        const existingHeaders = await (nextConfig.headers?.() ?? []);
        return [
          ...existingHeaders,
          {
            source: '/((?!api|_next|static|favicon.ico).*)',
            headers: [{ key: 'Vary', value: 'Accept, User-Agent' }],
          },
        ];
      },
    };
  };
}

/**
 * Auto-detect the Next.js `app/` directory from common locations.
 */
function detectAppDir(): string | null {
  const cwd = process.cwd();
  const candidates = [join(cwd, 'app'), join(cwd, 'src', 'app')];

  for (const candidate of candidates) {
    if (existsSync(candidate)) {
      return candidate;
    }
  }

  return null;
}

// Auto-generated file banner
const GENERATED_BANNER = `// AUTO-GENERATED by @agent-seo/next — do not edit manually.
// This file is created by withAgentSeo() in next.config.ts.
// Add "app/llms.txt" to your .gitignore.
`;

/**
 * Write `app/llms.txt/route.js` with a handler that auto-discovers routes.
 */
function generateLlmsTxtRoute(
  appDir: string,
  options: WithAgentSeoOptions,
): void {
  const routeDir = join(appDir, 'llms.txt');
  const routeFile = join(routeDir, 'route.js');

  // Serialize the options we need into the generated file
  const siteName = escapeStr(options.siteName);
  const siteDescription = escapeStr(options.siteDescription);
  const baseUrl = escapeStr(options.baseUrl);
  const excludePatterns = JSON.stringify(options.exclude || ['/api']);

  const content = `${GENERATED_BANNER}
import { generateLlmsTxt, discoverNextRoutes } from '@agent-seo/next';
import path from 'node:path';

const appDir = path.resolve(process.cwd(), 'app');

export async function GET(request) {
  const url = new URL(request.url);

  const routes = discoverNextRoutes(appDir, {
    exclude: ${excludePatterns},
  });

  const result = generateLlmsTxt(
    {
      siteName: '${siteName}',
      siteDescription: '${siteDescription}',
      baseUrl: process.env.NEXT_PUBLIC_BASE_URL || '${baseUrl}',
    },
    routes,
  );

  return new Response(result.llmsTxt, {
    status: 200,
    headers: {
      'Content-Type': 'text/plain; charset=utf-8',
      'Content-Disposition': 'inline',
      'Cache-Control': 'public, max-age=3600, s-maxage=3600',
    },
  });
}
`;

  // Only write if the file doesn't exist or content has changed
  mkdirSync(routeDir, { recursive: true });

  let existingContent = '';
  try {
    const { readFileSync } = require('node:fs');
    existingContent = readFileSync(routeFile, 'utf-8');
  } catch {
    // File doesn't exist yet
  }

  if (existingContent !== content) {
    writeFileSync(routeFile, content, 'utf-8');
  }
}

function escapeStr(s: string): string {
  return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

/**
 * Write `app/api/agent-seo-transform/route.js` — a Node.js API route that
 * receives a `?path=/some-page` param, fetches the HTML from the local
 * Next.js server, runs the core `transform()` pipeline (JSDOM → Readability
 * → Turndown), and returns clean Markdown.
 */
function generateTransformRoute(
  appDir: string,
  options: WithAgentSeoOptions,
): void {
  const routeDir = join(appDir, 'api', 'agent-seo-transform');
  const routeFile = join(routeDir, 'route.js');

  const baseUrl = escapeStr(options.baseUrl);

  const content = `${GENERATED_BANNER}
import { transform } from '@agent-seo/next';

// Force Node.js runtime (required for jsdom / Readability / Turndown)
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const pagePath = searchParams.get('path') || '/';

  // Build the internal URL to fetch the original HTML page
  const origin = process.env.NEXT_PUBLIC_BASE_URL || request.headers.get('x-forwarded-proto') + '://' + request.headers.get('host') || '${baseUrl}';
  const pageUrl = new URL(pagePath, origin);

  try {
    // Fetch the page HTML from the local server with a normal User-Agent
    // to avoid infinite rewrite loops
    const res = await fetch(pageUrl.toString(), {
      headers: {
        'User-Agent': 'AgentSEO-Internal/1.0',
        'Accept': 'text/html',
      },
    });

    if (!res.ok) {
      return new Response('Page not found', { status: 404 });
    }

    const html = await res.text();

    const result = await transform(html, {
      url: pageUrl.toString(),
    });

    return new Response(result.markdown, {
      status: 200,
      headers: {
        'Content-Type': 'text/markdown; charset=utf-8',
        'Content-Disposition': 'inline',
        'Cache-Control': 'public, max-age=3600, s-maxage=3600',
        'Vary': 'Accept, User-Agent',
        'X-Robots-Tag': 'all',
        'X-Agent-Seo': 'transformed',
      },
    });
  } catch (err) {
    console.error('[agent-seo] Transform error:', err);
    return new Response('Transform failed', { status: 500 });
  }
}
`;

  mkdirSync(routeDir, { recursive: true });

  let existingContent = '';
  try {
    const { readFileSync } = require('node:fs');
    existingContent = readFileSync(routeFile, 'utf-8');
  } catch {
    // File doesn't exist yet
  }

  if (existingContent !== content) {
    writeFileSync(routeFile, content, 'utf-8');
  }
}

/**
 * Write `app/robots.txt` — a static robots.txt that allows all crawlers
 * and references /llms.txt for AI agents.
 * Only created if the file doesn't already exist (won't overwrite user customizations).
 */
function generateRobotsTxt(
  appDir: string,
  options: WithAgentSeoOptions,
): void {
  const robotsFile = join(appDir, 'robots.txt');

  // Don't overwrite user-created robots.txt
  if (existsSync(robotsFile)) {
    return;
  }

  let content = `# AI-Optimized robots.txt — Generated by @agent-seo/next
# For AI agents: see /llms.txt for a structured site manifest

User-agent: *
Allow: /
`;

  if (options.sitemap) {
    const sitemapUrl =
      typeof options.sitemap === 'string'
        ? options.sitemap
        : `${options.baseUrl}/sitemap.xml`;
    content += `\nSitemap: ${sitemapUrl}\n`;
  }

  writeFileSync(robotsFile, content, 'utf-8');
}
